<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Jetpack系列其二livedata]]></title>
    <url>%2F2019%2F11%2F07%2FJetpack-livedata%2F</url>
    <content type="text"><![CDATA[前言livedata是被观察者的持有类，并能感应生命周期。此篇文章重在分析两点 livedata如何实现观察者模式的 livedata是如何感知数据流的变化的 livedata是如何感知lifecycleOwner的生命周期的 使用与分析livedata一般是配合viewmodel使用的，首先看看下面的使用案例 class StoreViewModel: ViewModel { // 初始化 val articles: MutableLiveData&lt;MutableList&lt;Article>> = MutableLiveData() fun loadArticles(page: Int) { // 网络请求应放在对应repository中，这里为了方便说明 CoroutineScope(Dispatchers.IO).launch { val articlesWrapper = apiCenter().homeArticles(page.toString()) // 从服务器获取数据 articles.postValue(articlesWrapper.data.datas.toMutableList()) } } } class HomeFragment : BaseFragment() { fun initialized() { vm.articles.observe(this, Observer&lt;MutableList&lt;Article>> { // 通知UI更新 }) } } 接下来看看，在livedata内部是如何感知数据流变化的 // livedata的构造方法 public LiveData(T value) { mData = value; mVersion = START_VERSION + 1; } public LiveData() { mData = NOT_SET; mVersion = START_VERSION; } // 其中mData就是存储的数据了，version可以看做存储数据的当前版本 protected void postValue(T value) { boolean postTask; synchronized (mDataLock) { postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { return; } ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); } // 发送数据到主线程，如果在主线程执行完任务之前postValue多次，那么只会分发最后一次的value // ArchTaskExecutor.getInstance().postToMainThread其实就是调用主线程的Handler将value传递到主线程 private final Runnable mPostValueRunnable = new Runnable() { @Override public void run() { Object newValue; synchronized (mDataLock) { newValue = mPendingData; mPendingData = NOT_SET; } //noinspection unchecked setValue((T) newValue); } }; @MainThread protected void setValue(T value) { assertMainThread("setValue"); mVersion++; mData = value; dispatchingValue(null); } // 在这里会给mData重新赋值，然后做分发 // 在MutableLiveData中的setValue其实就是调用这个方法，在主线程中如果要直接给livedata赋值，可以直接调用此方法 // 再来看看livedata内部的观察者 private SafeIterableMap&lt;Observer&lt;? super T>, ObserverWrapper> mObservers = new SafeIterableMap&lt;>(); // 它其实是个双向列表 有如下优点 // 1.直接移动指针插入且无需执行hash算法效率高 // 2.可以一边遍历一遍删除元素而不会引起ConcurrentModifiedException // 3.使用双向链表存储数据比HashMap(java8)更节省空间 // 向livedata添加一个观察者 @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T> observer) { assertMainThread("observe"); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); // 如果Map中不存在就放置进去并返回Null，如果存在直接拿出 ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper); } // LifecycleBoundObserver 生命周期边界的观察者 // LifecycleBoundObserver 它既是livedata事件的观察者又是生命周期变化的观察者，换句话来说，它既能感知livedata数据流的变化也能感知lifecycleOwner生命周期的变化 // 它被添加到了mObservers中也被添加到了LifecycleRegistry的mObserverMap: FastSafeIterableMap中 // 再来看看livedata是如何将数据变化下发到每一个观察者的 // 如果传值就是通知指定的observer，传Null就是通知所有的observer void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { considerNotify(initiator); initiator = null; } else { for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T>, ObserverWrapper>> iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false; } // 这里跳过分析SafeIterableMap，FastSafeIterableMap，先把它们当作普通的迭代器，着重看下considerNotify private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion >= mVersion) { return; } observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData); } // 前面说了，这里的ObserverWrapper的实例是LifecycleBoundObserver // 通知观察者之前首先会检查lifecycleOwner的生命周期然后再检测数据的版本，都符合要求才会通知数据更新 到这里，livedata内部数据流动与感知的过程已大体分析完成了，它内部用SafeInterableMap作为观察者的容器，在数据发生变化的时候分发给所有的观察者，在lifecycleOwner生命周期发生变化时也会通过LifecycleBoundObserver的onStateChanged通知数据分发。 梳理了一下流程图： livedata实际应用livedata事件总线简单实现import androidx.annotation.MainThread import androidx.lifecycle.LifecycleOwner import androidx.lifecycle.MutableLiveData import androidx.lifecycle.Observer import java.lang.Exception class LiveDataBus private constructor() { private val mLock = Object() companion object { val instance: LiveDataBus = LiveDataBus() } private val bus: HashMap&lt;String, BusLiveData&lt;Any>> by lazy { HashMap&lt;String, BusLiveData&lt;Any>>() } fun subscribe(owner: LifecycleOwner, observer: Observer&lt;Any>, event: String) { if (bus.containsKey(event)) { val wrapper = BusLiveDataWrapper(observer) val liveData = bus[event] if (liveData?.alreadySubmit == false) { wrapper.scrapPreEvent = true liveData.alreadySubmit = true } bus[event]?.observe(owner, wrapper) } } fun postEvent(event: String, addition: Any) { if (bus.containsKey(event)) { bus[event]?.postValue(addition) } else { synchronized(mLock) { bus[event] = BusLiveData(addition) } } } @MainThread fun setEvent(event: String, addition: Any) { if (bus.containsKey(event)) { bus[event]?.value = addition } else { bus[event] = BusLiveData(addition) } } inner class BusLiveData&lt;T>(t: T) : MutableLiveData&lt;T>(t) { var alreadySubmit: Boolean = false } inner class BusLiveDataWrapper&lt;T> constructor( private val observer: Observer&lt;T>, var scrapPreEvent: Boolean = false ) : Observer&lt;T> { override fun onChanged(t: T) { if (scrapPreEvent) { scrapPreEvent = true return } try { observer.onChanged(t) } catch (e: Exception) { // catch ClassCastException etc. e.printStackTrace() } } } } 结语最后，做下总结，livedata的大致流程已经分析完了，但是比较重要的类LifecycleRegistry只是一笔带过了没有做分析，它是如何将生命周期变化事件分发到订阅者的呢？另外还有两个比较重要的数据结构FastSafeIterableMap和SafeIterableMap，在这里先记录一下啦，以后再填上吧。🖖 参考 LiveData Overview by Android Developers 用LiveDataBus替代RxBus、EventBus——Android消息总线的演进之路 by 美团技术团队 海亮]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koltin委托属性]]></title>
    <url>%2F2019%2F10%2F24%2FKotlinDelegate%2F</url>
    <content type="text"><![CDATA[委托模式在Kotlin中委托模式通过by关键字实现 interface Base { fun print() } class Derived(b: Base): Base by b 上述表达式表示b将代理Derived去实现interface Base的方法。 委托属性延迟属性(Lazy)Kotlin标准库中有很多有用的委托属性(delegates，代理属性)，像使用lazy方法创建一个对象，只有在第一次使用的时候会被初始化。 lazy的重载方法 public actual fun &lt;T> lazy(initializer: () -> T): Lazy&lt;T> = SynchronizedLazyImpl(initializer) public actual fun &lt;T> lazy(lock: Any?, initializer: () -> T): Lazy&lt;T> = SynchronizedLazyImpl(initializer, lock) public actual fun &lt;T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy&lt;T> = when (mode) { LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer) LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer) LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer) } 由上可见，Lazy接口的实现类有三种SynchronizedLazyImpl，SafePublicationLazyImpl，UnsafeLazyImpl，前两者线程安全，但是实现方法有所不同，分别使用线程锁和原子类实现 private class SynchronizedLazyImpl&lt;out T>(initializer: () -> T, lock: Any? = null) : Lazy&lt;T>, Serializable { private var initializer: (() -> T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress("UNCHECKED_CAST") return _v1 as T } return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress("UNCHECKED_CAST") (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet." private fun writeReplace(): Any = InitializedLazyImpl(value) } private class SafePublicationLazyImpl&lt;out T>(initializer: () -> T) : Lazy&lt;T>, Serializable { @Volatile private var initializer: (() -> T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // this final field is required to enable safe publication of constructed instance private val final: Any = UNINITIALIZED_VALUE override val value: T get() { val value = _value if (value !== UNINITIALIZED_VALUE) { @Suppress("UNCHECKED_CAST") return value as T } val initializerValue = initializer // if we see null in initializer here, it means that the value is already set by another thread if (initializerValue != null) { val newValue = initializerValue() if (valueUpdater.compareAndSet(this, UNINITIALIZED_VALUE, newValue)) { initializer = null return newValue } } @Suppress("UNCHECKED_CAST") return _value as T } override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet." private fun writeReplace(): Any = InitializedLazyImpl(value) companion object { private val valueUpdater = java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater( SafePublicationLazyImpl::class.java, Any::class.java, "_value" ) } } internal class UnsafeLazyImpl&lt;out T>(initializer: () -> T) : Lazy&lt;T>, Serializable { private var initializer: (() -> T)? = initializer private var _value: Any? = UNINITIALIZED_VALUE override val value: T get() { if (_value === UNINITIALIZED_VALUE) { _value = initializer!!() initializer = null } @Suppress("UNCHECKED_CAST") return _value as T } override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE override fun toString(): String = if (isInitialized()) value.toString() else "Lazy value not initialized yet." private fun writeReplace(): Any = InitializedLazyImpl(value) } 至于3者的区别，官方文档上已有说明，如果该值只在一个线程中计算，并且所有线程会看到相同的值就使用SynchronizedLazyImpl；如果该值在多个线程可以同时执行，那么使用SafePublicationLazyImpl；如果初始化发生与使用在同一个线程就使用UnsafeLazyImpl，它不会有任何线程安全的保证和开销。 可观察属性(Observable)在kotlin.properties.Delegates中，可以找到相关方法，分别是observable和vetoable，它们在被观察者的值发生改变时会执行回调，回调有三个值分别时被观察者的类型，旧值与新值；两者的区别在于，vetoable是否给被观察者赋值取决与回调函数的返回值。 var name: String by Delegates.observable("") { property, oldValue, newValue -> } var age: String by Delegates.vetoable("") { property, oldValue, newValue -> false } map代理(map delegate)暂时没有使用过这种代理。 class User(val map: Map&lt;String, Any?>) { val name: String by map val age: Int by map } 按照官方文档的例子，来看传入键值对，map代理会根据键值给相对的属性赋值，相关的实现方法如下 @kotlin.internal.InlineOnly public inline operator fun &lt;V, V1 : V> Map&lt;in String, @Exact V>.getValue(thisRef: Any?, property: KProperty&lt;*>): V1 = @Suppress("UNCHECKED_CAST") (getOrImplicitDefault(property.name) as V1) @kotlin.jvm.JvmName("getOrImplicitDefaultNullable") @PublishedApi internal fun &lt;K, V> Map&lt;K, V>.getOrImplicitDefault(key: K): V { if (this is MapWithDefault) return this.getOrImplicitDefault(key) return getOrElseNullable(key, { throw NoSuchElementException("Key $key is missing in the map.") }) } 如果传入的map没有实现MapWithDefault接口，key不存在时会抛出NoSuchElementException异常，因此初始化map时，需要做类似如下操作： emptyMap&lt;String, String>().withDefault { key -> "" } 这样找不到相对应的key-value时，就会使用默认值了，实现方法如下： internal inline fun &lt;K, V> Map&lt;K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V { val value = get(key) if (value == null &amp;&amp; !containsKey(key)) { return defaultValue() } else { @Suppress("UNCHECKED_CAST") return value as V } } 使用的场景没有遇到过，但是有相关博客说，如果需要预定义keys的时候可以使用，相关博文会贴在下面 使用范例Shared Preferencesprivate inline fun &lt;T> SharedPreferences.delegate( defaultValue: T, key: String?, crossinline getter: SharedPreferences.(String, T) -> T, crossinline setter: Editor.(String, T) -> Editor ): ReadWriteProperty&lt;Any, T> { return object: ReadWriteProperty&lt;Any, T> { override fun getValue(thisRef: Any, property: KProperty&lt;*>) = getter(key?:property.name, defaultValue) override fun setValue(thisRef: Any, property: KProperty&lt;*>, value: T) = edit().setter(key?:property.name, value).apply() } } 有了如上方法我们就可以改造SharedPreferences了： // 存储Int fun SharedPreferences.int(def: Int=0, key: String?=null) = delegate(def, key, SharedPreferences::getInt, Editor::putInt) // 存储Long fun SharedPreferences.long(def: Long=0L, key: String?=null) = delegate(def, key, SharedPreferences::getLong), Editor::putLong) 使用 var sthInt by prefs.int() init { sthInt = 1 } // sthInt的getter和setter都被代理了，取值时实际上调用的是SharedPreferences::getInt，被赋值的同时，也通过Editor::putInt将值存入了SharedPreferences中。 更多的使用案例会逐一的添加的此篇中。 参考Kotlin delegates in Android development - Part1 by Fabio Collini Kotlin 委托属性]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment原理浅析]]></title>
    <url>%2F2019%2F09%2F29%2FFragment%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言Fragment在日常开发中非常的常用，一版都是配合ViewPager或FrameLayout使用，我们基本不用担心操作它attachToActivity，因为FragmentManager都帮我们处理好了。那么Fragment是如何绑定Activity的生命周期的呢？系统是如何将Fragment添加到视图层的呢？Fragment的回退栈又是什么呢？带着这些问题我们开始探索Fragment的源码吧。 基本操作首先来回顾一下，我们如何添加Fragment的: val fm = supportFragmentManager val ts = fm.beginTransaction() ts.add(fragment) ts.commit() 首先弄清几个概念： FragmentController 主要作用是绑定Activity与Fragment的生命周期，在FragmentActivity可以看到在每个生命周期函数，FragmentController都有做分发，最终交给了FragmentManager处理 FragmentManager Fragments的直接操作者，管理Fragment的内部状态以及添加\移除\隐藏\显示Fragment等操作 FragmentTransaction 对Fragment操作的集合，各项操作会存储在Ops中，最终在FragmentManager中被执行 tips: FragmentTransaction本身是一个抽象类，它包含着一个内部类Op，根据其构造函数可以看出来这个类用于记录Fragment的操作，并将这一系列操作存储在mOps，其中四个抽象方法commit/commitAllowingStateLoss/commitNow/commitNowAllowingStateLoss就是我们经常放在最后执行的方法了。 // fm.beginTransaction() @NonNull @Override public FragmentTransaction beginTransaction() { return new BackStackRecord(this); } BackStackRecord继承了FragmentTransaction，可以看到在这个类中最终还是调用了FragmentManager的enqueueAction方法，将所有的操作加入执行队列中。并对需要记录Fragment回退栈的操作做如下处理： public int allocBackStackIndex(BackStackRecord bse) { synchronized (this) { if (mAvailBackStackIndices == null || mAvailBackStackIndices.size() &lt;= 0) { if (mBackStackIndices == null) { mBackStackIndices = new ArrayList&lt;BackStackRecord>(); } int index = mBackStackIndices.size(); if (DEBUG) Log.v(TAG, "Setting back stack index " + index + " to " + bse); // 将当前操作添加到数组中 mBackStackIndices.add(bse); return index; } else { // 找到一个可用的位置进行存储当前操作 int index = mAvailBackStackIndices.remove(mAvailBackStackIndices.size()-1); if (DEBUG) Log.v(TAG, "Adding back stack index " + index + " with " + bse); mBackStackIndices.set(index, bse); return index; } } } 最终调用了FragmentManager的enqueueAction/execSingleAction： public boolean execPendingActions() { // 校验准备工作 ensureExecReady(true); boolean didSomething = false; // 初始化数据源 while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) { mExecutingActions = true; try { removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop); } finally { // 清除执行程序 cleanupExec(); } didSomething = true; } updateOnBackPressedCallbackEnabled(); // 等待加载延迟的Fragment doPendingDeferredStart(); burpActive(); return didSomething; } public void execSingleAction(OpGenerator action, boolean allowStateLoss) { if (allowStateLoss &amp;&amp; (mHost == null || mDestroyed)) { // This FragmentManager isn't attached, so drop the entire transaction. return; } ensureExecReady(allowStateLoss); if (action.generateOps(mTmpRecords, mTmpIsPop)) { mExecutingActions = true; try { removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop); } finally { cleanupExec(); } } updateOnBackPressedCallbackEnabled(); doPendingDeferredStart(); burpActive(); } 无论是执行execPendingActions还是execSingleAction，其核心方法还是removeRedundantOperationsAndExecute，这个方法可以移除冗余的操作，举个例子，如果两个事务一起执行，一个用于添加FragmentA，一个用于将FragmentA替换成FragmentB，实际上只有FragmentB会被添加，无法感应到FragmentA的创建/销毁生命周期。这个就是移除冗余操作的副作用了，Fragment的状态不会如预想那样变化。疑问，这个方法是如何去除冗余操作的呢？ // 移除冗余的回退栈操作再执行，需要设置setReorderingAllowed(true) private void removeRedundantOperationsAndExecute(ArrayList&lt;BackStackRecord> records, ArrayList&lt;Boolean> isRecordPop) { // 省略... final int numRecords = records.size(); int startIndex = 0; for (int recordNum = 0; recordNum &lt; numRecords; recordNum++) { final boolean canReorder = records.get(recordNum).mReorderingAllowed; // 所有事务如果设置了setReorderingAllowed(true)则全部跳过在最后一起执行 if (!canReorder) { // execute all previous transactions // 如果中间有事务A没有设置setReorderingAllowed(true)，则从startIndex到事务A会被一起执行 if (startIndex != recordNum) { executeOpsTogether(records, isRecordPop, startIndex, recordNum); } // execute all pop operations that don't allow reordering together or one add operation // 上述注释说明此处执行所有不允许一起排序的pop操作 // 在BackStackRecord中isRecordPop都为false，在PopBackStackState中isRecordPop都为true，这两个类分别对应着入栈和出栈，且仅当BackStackRecord设置了addToBackStack后才会被记录 int reorderingEnd = recordNum + 1; if (isRecordPop.get(recordNum)) { while (reorderingEnd &lt; numRecords &amp;&amp; isRecordPop.get(reorderingEnd) &amp;&amp; !records.get(reorderingEnd).mReorderingAllowed) { reorderingEnd++; } } executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd); startIndex = reorderingEnd; recordNum = reorderingEnd - 1; } } if (startIndex != numRecords) { executeOpsTogether(records, isRecordPop, startIndex, numRecords); } } 接着往下看executeOps private static void executeOps(ArrayList&lt;BackStackRecord> records, ArrayList&lt;Boolean> isRecordPop, int startIndex, int endIndex) { for (int i = startIndex; i &lt; endIndex; i++) { final BackStackRecord record = records.get(i); final boolean isPop = isRecordPop.get(i); if (isPop) { record.bumpBackStackNesting(-1); boolean moveToState = i == (endIndex - 1); // 执行PopBackStackState record.executePopOps(moveToState); } else { record.bumpBackStackNesting(1); // 执行BackStackRecord record.executeOps(); } } } 然后是BackStackRecord的executeOps，最终这些ops由FragmentManager处理，将Fragment添加至mAdded或者从mAdded中移除，并对Fragment的内部状态进行修改。 最后也是最重要的方法moveToState，它主要负责修改Fragment的生命周期状态，在这我们可以看到Fragment是如何被添加至容器中的，在此Fragment中内部状态通过FragmentManger更新。 case Fragment.CREATED: //省略... f.mContainer = container; f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState); if (f.mView != null) { f.mInnerView = f.mView; f.mView.setSaveFromParentEnabled(false); if (container != null) { // 将fragment的视图添加到宿主的容器中 container.addView(f.mView); } if (f.mHidden) { f.mView.setVisibility(View.GONE); } // 省略... } else { f.mInnerView = null; } // 省略... 至此，文章开始的疑问差不多都解决了，最后再梳理一下Fragment初始化流程。流程图大体如下： 结语Fragment的逻辑复杂，如果仅仅是靠读源码，是无法理清其复杂的逻辑关系的。此文的目的只是对Fragment做一次简单的探索，弄清楚它是如何被添加到视图的，如何去感知Activity的生命周期的，至于它的高级用法以及使用注意事项将会发布在其后的文章。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多渠道打包及加固方案]]></title>
    <url>%2F2019%2F09%2F25%2FAndroid%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E5%8F%8A%E5%8A%A0%E5%9B%BA%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言Android多渠道打包已经是老生常谈的问题了，各个大厂也先后开源了自己的打包方案，为我们开发者带来不少便捷。今天我就来谈谈美团的Walle，我在项目中也正是用到了它，也算做个总结和备忘吧。本篇中会提及Walle的基本使用方法以及如何在项目中配置加固使用，当然，最后也稍微会从源码的角度去分析一下这个方案的原理。那么，现在开始吧。 如何使用参考Walle项目Github首页，操作如下：在工程目录引入 buildscript { dependencies { classpath 'com.meituan.android.walle:plugin:1.1.6' } } 在app目录下引入 apply plugin: 'walle' dependencies { // 用于读取渠道号 compile 'com.meituan.android.walle:library:1.1.6' } 配置信息呢，可以参考官方说明，我这就简单记录下(copy)了 walle { // 指定渠道包的输出路径 apkOutputFolder = new File("${project.buildDir}/outputs/channels"); // 定制渠道包的APK的文件名称 apkFileNameFormat = '${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk'; // 渠道配置文件 一个渠道占一行 channelFile = new File("${project.getProjectDir()}/channel") } 不要忘记获取渠道信息 val channel = WalleChannelReader.getChannel(context) UMConfigure.init(this, UMENG_APP_KEY, channel, UMConfigure.DEVICE_TYPE_PHONE, "") 接下来只需要在gradle任务执行channelRelease或是执行 gradlew clean assembleReleaseChannels 渠道包就能生成在你指定的目录下面了。 但是这样操作完之后就没问题了吗？显然不是。通常我们发布自己的应用之前，还需要进行应用加固(360或是乐固，本文用的是乐固)，加固后会清除apk的签名和渠道信息，需要重新签名然后写入渠道信息。因此，打渠道变成了如下流程： 要满足上面的操作，项目中walle的配置显然就不太合适了，幸亏walle团队也有提供命令行工具walle-cli供我们自行打包，为了方便，我自己写了个简单的脚本，自动上传到乐固加固然后进行签名写入渠道信息，具体可以参考一下autoReinforce的项目说明。 源码分析有几个问题想问下大家。 渠道信息写在哪里了呢？为什么写在这个位置呢？ 渠道信息是如何进行读写操作的呢？ 第一个问题很简单啦，文档上也说了写在了Apk中的APK Signature Block区块，如下图，之所以写在这个位置是因为v2不会对该区域进行校验。 在payload_reader可以找到写入渠道的逻辑，在讲述逻辑之前，我们首先要了解一下EOCD(End of Centtal Directory)的结构： offset Bytes Description 0 4 End of central directory signature = 0x06054b50 4 2 Number of this disk 6 2 Disk where central directory starts 8 2 Number of central directory records on this disk 10 2 Total number of central directory records 12 4 Size of central directory (bytes) 16 4 Offset of start of central directory, relative to start of archive 20 2 Comment length (n) 22 n Comment 由于渠道信息是写在APK Signature Block，因此只要找到Center Directory的位置，那么往前就能找到Apk Signing Block的位置。在Walle中，通过循环找到魔数0x06054b50(假设Comment为空，通过增加Comment的长度，确定EOCD block的位置)，从而确定comment的长度，再将长度与Comment length对比，只要能确认Comment的长度，就能确认APK Signature Block的位置了。APK Signature Block结构如下表所示： offset Bytes Description @+0 8 block的长度(当前长度不计算在内) @+8 n ID-value值 @-24 8 block的长度 @-16 16 魔数”APK Sig Block 42” walle渠道信息就是写在ID-value中，在上一步中已经拿到Center Directory的offset，再向前24bytes，取8bytes，就能拿到APK Signature Block的长度了，注意这个长度是不包括前面8个bytes的，在walle中向前多偏移了8个bytes，取首尾block长度对比进行校验，代码片段如下： // Find the APK Signing Block. The block immediately precedes the Central Directory. if (centralDirOffset &lt; APK_SIG_BLOCK_MIN_SIZE) { throw new SignatureNotFoundException( "APK too small for APK Signing Block. ZIP Central Directory offset: " + centralDirOffset); } // 后面16bytes就是魔数啦 加上前面8bytes的black长度信息，24bytes // * 16 bytes: magic fileChannel.position(centralDirOffset - 24); final ByteBuffer footer = ByteBuffer.allocate(24); fileChannel.read(footer); footer.order(ByteOrder.LITTLE_ENDIAN); // 这里不是很清楚为什么要将魔数拆开来对比？ if ((footer.getLong(8) != APK_SIG_BLOCK_MAGIC_LO) || (footer.getLong(16) != APK_SIG_BLOCK_MAGIC_HI)) { throw new SignatureNotFoundException( "No APK Signing Block before ZIP Central Directory"); } // 尾部记录的block长度 final long apkSigBlockSizeInFooter = footer.getLong(0); if ((apkSigBlockSizeInFooter &lt; footer.capacity()) || (apkSigBlockSizeInFooter > Integer.MAX_VALUE - 8)) { throw new SignatureNotFoundException( "APK Signing Block size out of range: " + apkSigBlockSizeInFooter); } // 将总长度与头部记录的8bytes长度相加 final int totalSize = (int) (apkSigBlockSizeInFooter + 8); final long apkSigBlockOffset = centralDirOffset - totalSize; if (apkSigBlockOffset &lt; 0) { throw new SignatureNotFoundException( "APK Signing Block offset out of range: " + apkSigBlockOffset); } fileChannel.position(apkSigBlockOffset); final ByteBuffer apkSigBlock = ByteBuffer.allocate(totalSize); fileChannel.read(apkSigBlock); apkSigBlock.order(ByteOrder.LITTLE_ENDIAN); // 头部和尾部的长度杜比校验 final long apkSigBlockSizeInHeader = apkSigBlock.getLong(0); if (apkSigBlockSizeInHeader != apkSigBlockSizeInFooter) { throw new SignatureNotFoundException( "APK Signing Block sizes in header and footer do not match: " + apkSigBlockSizeInHeader + " vs " + apkSigBlockSizeInFooter); } // 拿到APK Signing Block了 再来看看ID-value区域结构 Bytes Description 8 序列长度n(不包括其本身) 4 序列id n-4 内容 了解了ID-value区域结构那么再贴一下获取custom ID-value的代码 // APK Sig Block 中的ID-value区域 final ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24); final Map&lt;Integer, ByteBuffer> idValues = new LinkedHashMap&lt;Integer, ByteBuffer>(); // keep order int entryCount = 0; while (pairs.hasRemaining()) { entryCount++; if (pairs.remaining() &lt; 8) { throw new SignatureNotFoundException( "Insufficient data to read size of APK Signing Block entry #" + entryCount); } // 获取总长度 8bytes final long lenLong = pairs.getLong(); if ((lenLong &lt; 4) || (lenLong > Integer.MAX_VALUE)) { throw new SignatureNotFoundException( "APK Signing Block entry #" + entryCount + " size out of range: " + lenLong); } final int len = (int) lenLong; // id开始的位置 final int nextEntryPos = pairs.position() + len; if (len > pairs.remaining()) { throw new SignatureNotFoundException( "APK Signing Block entry #" + entryCount + " size out of range: " + len + ", available: " + pairs.remaining()); } // 获取id 4bytes final int id = pairs.getInt(); idValues.put(id, getByteBuffer(pairs, len - 4)); pairs.position(nextEntryPos); } 至此就分析完了如何在APK中去读取插入的渠道信息，顺带了解了一下APK包的结构。最后过一下如何写入渠道信息的吧，流程如下： 通过commentLength\centralDirStartOffset\apkSigningBlockAndOffset找到IdValues的位置 在IdValues block中找到V2签名的位置，判断是否已经签名 判断是否使用V3签名，如果有将长度补成4096的倍数(V3签名会校验) 写入渠道 结语从多渠道打包，引申出了Apk的签名V2签名逻辑(V1类似，但是是放在EOCD的Comment中)，Apk(Zip)包的结构等问题。这里只是简单的做下自我总结，如有疑问欢迎留言，当然你也可以选择去看看官方的文档和大神们的博客。 参考 带你了解腾讯开源的多渠道打包技术 VasDolly源码解析 by 鸿洋 APK文件结构详解 Meituan-Dianping/walle Tencent/VasDolly]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps搭建ssr服务器]]></title>
    <url>%2F2019%2F09%2F21%2Fvps%E6%90%AD%E5%BB%BAssr%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言发现最近一些搭建ssr服务器的教程都被迫下线了，心里慌的一匹，原先都是参照教程来搭建的，没有教程我可怎么办，赶紧备份一波。 vps服务器选择原先一直用搬瓦工，因为便宜啊，用了一年多ip被封了，花了将近10美元重置，一天不到又给我封了，遂换成vultr(1RMB一天)，这个比搬瓦工(9.99美元一年)贵上不少，但是好在能随时免费换ip，这个ip被封了，我再换一个。下面的服务商我就没用过了，先记录着，万一哪一天vultr也不好用了呢。 商家 价格(最低配) https://digital-vm.com $4/MONTHLY $41/YEARLY https://www.onevps.com $4/MONTHLY www.fastcomet.com $2.95/MONTHLY https://www.hostkvm.com $9.5/MONTHLY https://www.locvps.com 68RMB/MONTHLY https://zheye.io 88RMB/MONTHLY https://www.jwdns.com 88RMB/MONTHLY https://hxkvm.com 65RMB/MONTHLY https://www.gke.cc 65RMB/MONTHLY www.aoyouhost.com 48RMB/MONTHLY 注1：这里只进行价格对比，详细配置还需自行仔细查看注2：如果选择了vultr，一定要先测试一下服务器ip是否被墙了，然后再进行下面的操作，如果被墙了，请换一台服务器再试！ 部署(非新手向) 安装脚本 wget --no-check-certificate https://freed.ga/github/shadowsocksR.sh; bash shadowsocksR.sh 注：根据脚本提示选择密码，端口号等，最后请小心保存配置信息 安装锐速 留意看自己服务器所安装的系统，如果是centos6*64，执行如下命令： wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/hombo125/doubi/master/appex.sh && bash appex.sh install '2.6.32-642.el6.x86_64' 如果是centos7*64则需先更换系统内核 wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/hombo125/doubi/master/rskernel.sh && bash rskernel.sh 然后再安装锐速 yum install net-tools -y && wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh && bash appex.sh install 配置信息如下图所示(其实不是很明白第一项为啥选n) 结束语到这里，所有流程都已经走完了，最后提醒大家所有的配置信息一定要妥善保存哟。 参考 用VPS搭建SSR服务器教程(写的真的很详细，新手小伙伴可以过去学习一下)]]></content>
      <categories>
        <category>ssr</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin语法糖 Part3]]></title>
    <url>%2F2019%2F04%2F05%2FKotlin%E8%AF%AD%E6%B3%95%E7%B3%96Part3%2F</url>
    <content type="text"><![CDATA[前言在前面的两篇文章中，我们了解到了： sealed when() with() inline function and reified type 在这章中，我会给大家分享我是如何使用Kotlin委托机制的。 Kotlin的委托机制Kotlin有一个内置的委托模式。在一些书中也提及委托模式是实现继承的一个很好的替代方式，在Kotlin使用它进行聚合非常容易： interface Navigable { val onNavigationClick: (()->Unit)? } interface Searchable { val searchText:String } class Component(navigation: Navigable, searchable: Searchable): Navigable by navigable, Searchabe by searchable 使用by关键字，即可委托navigation、searchable的所有行为。比起Java，Kotlin减少了大量的模板代码。如果你把interface标记为internal，你会发现编译不能通过 ‘public’ function exposes its ‘internal’ parameter type xxx Kotlin编译器不允许暴露模块的内部组件，如果想在不暴露Navigable，Searchable的前提下解决这个问题，你只需要做： 移除构造器 使用组合代替聚合 定义包含Navigable和Searchable方法名的ComponentInterface interface ComponentInterface { val onNavigationClick: (()->Unit)? var searchText: String } class Component: ComponentInterface { private val navigable: Navigable = NavigableImpl() private val searchable: Searchable = SearchableImpl() override val onNavigationClick: (()->Unit)? get() = navigable.onNavigationClick override var searchText: String = "" get() = searchable.searchText set(value) { field = value searchable.searchText = value } } 经过改造后，你发现代码从零模板的聚合变成了看上去很讨厌的组合方式。但是先别哭，Kotlin总能给你带来愉悦的编码体验。Kotlin不仅支持使用by关键字对指定对象进行方法委派，还具有委托属性的机制。你可能已经在使用lazy关键字初始化对象时接触到了它的这一机制了。 private val lazyProperty by lazy { "" } 怎么从使用lazy()上来改造上面组合的代码呢，请看代码： class ReferencedProperty&lt;T>(private val get: () -> T, private val set: (T) -> Unit = {}) { operator fun getValue(thisRef: Any?, property: KProperty&lt;*>): T = get() operator fun setValue(thisRef: Any?, property: KProperty&lt;*>, value: T) = set(value) } fun &lt;T> ref(property: KMutableProperty0&lt;T>) = ReferencedProperty(property::get, property::set) fun &lt;T> ref(property: KProperty0&lt;T>) = ReferencedProperty(property::get) ReferencedProperty用两个方法作为参数，并定义了两个函数： get函数返回泛型T set函数以T作为参数 getValue()调用get() setValue()调用set() 最重要的一点是你需要知道操作符用到了属性代理机制。在ReferencedProperty类下，你会发现两个返回ReferencedProperty的泛型方法，第一个用于var，第二个用于val。现在让我们用ref()简化代码 class Component : ComponentInterface { private val navigable: Navigable = NavigableImpl() private val searchable: Searchable = SearchableImpl() override val onNavigationClick by ref(navigable::onNavigationClick) override var searchText by ref(searchable::searchText) } 希望看完这三章你能有些许收获。 参考6 magic sugars that can make your Kotlin codebase happier — Part 3]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin语法糖 Part2]]></title>
    <url>%2F2019%2F03%2F30%2Fkotlin%E8%AF%AD%E6%B3%95%E7%B3%96Part2%2F</url>
    <content type="text"><![CDATA[前言在第一章中，我们学会了如何使用sealed classes，以及when()配合Pair或Triple使用做多重条件判断。 在这一章中，我想跟大家分享一下with()和inline reified的基本使用。 使用with()函数with()函数位于Standard.kt，是Kotlin标准函数之一，大家可以看看，掌握好这些函数对于我们简化编程有很大的帮助，有时间我会另开一章分享我平时使用到它们的地方，当然也非常欢迎大家评论分享使用技巧。假设你从未使用过with()函数，我们可以先看看源码： inline fun &lt;T, R> with(receiver: T, block: T.() -> R): R Calls the specified function block with the given receiver as its receiver and returns its result. 大体的意思是调用receiver中的方法然后返回它的结果： val receiver: String = "Fructos" val block: String() -> Unit = { println(toUpperCase()) println(toLowerCase()) println(capitalize()) } val result: Unit = with&lt;String, Unit>(receiver, block) //简化一下代码 with(sugar) { println(toUpperCase()) println(toLowerCase()) println(capitalize()) } 在block中你可以调用到receiver的方法而且不需要任何限定符，在block的最后返回你需要的数据类型就可以了。在项目中我经常使用它在p层传递限定符像是view.show(),view.hide() interface View { fun show() fun hide() fun reset() fun clear() } class Presenter(private val view: View) { fun present(isFructos:Boolean) = with(view) { if(isFructos) { show() hide() } else { hide() clear() } } } inline reified我们先分析一下下面的代码 abstact class Item class MediaItem: Item() { val media = ... } class IconItem: Item() { val icon = ... } interface Renderer { fun render(view: View, item:Item) } class MediaItemRenderer: Renderer { override fun render(view: View, item: Item) { if(item !is MediaItem) { throw AssertionError("Item is not an instance of MediaItem") } view.showMedia(item.media) view.reset() } } class IconItemRenderer: Renderer { override fun render(view: Viewm, item: Item) { if(item !is IconItem) { throw AssertionError("Item is not an instance of IconItem") } view.showIcon(item.icon) view.reset() } } 上述代码有很多冗余的地方，其实很明显你就能看出MediaItemRenderer和IconItemRenderer在render()函数中存在着相同的逻辑，现在，我们用inline reified来改造它，首先将render函数中的逻辑提取出来： fun&lt;T> withCorrectType(toBeChecked: Item, block: (T) -> Unit) { if(toBeChecked !is T) { throw IllegalArgumentException("invalid Type") } block.invoke(toBeChecked) } 然而，这样做并不能通过编译，会报错 Cannot check for instance of erased type: T 产生这种错误是因为泛型机制。 During the type erasure process, the Java compiler erases all type parameters and replaces each with its first bound if the type parameter is bounded,or Object if the type parameter is unbounded.-docs.oracle.com so, 可以防止防止泛型T被清除吗？在Kotlin中一切都有可能，使用inline reified，就能修复这个问题。 class MediaItemRenderer: Renderer { override fun render(view: View, item: Item) = with(view) { withCorrectType&lt;MediaItem>(item) { show {it.media()} reset() } } } class IconItemRenderer: Renderer { override fun render(view: View, item: Item) = with(view) { withCorrectType&lt;IconItem>(item) { clear() show {it.icon()} } } } inline fun&lt;reified T> withCorrectType(toBeChecked: Item, block: (T) -> Unit) { if(toBeChecked !is T) { throw ... } block.invoke(toBeChecked) } 使用reified修饰符Kotlin compiler保留了你的类型，当然这是必须在使用inline的前提下。 以上就是第二章的全部了，在第三章中我们将展示更多的Kotlin小技巧。 参考6 magic sugars that can make your Kotlin codebase happier — Part 2]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin语法糖 Part1]]></title>
    <url>%2F2019%2F03%2F23%2Fkotlin%E8%AF%AD%E6%B3%95%E7%B3%96Part1%2F</url>
    <content type="text"><![CDATA[Kotlin给我们提供了大量的工具和语法糖让我们能够更为便利的去编程，让代码有更好的可读性和可扩展性。写更少的代码做更多的事，用这句话概括Kotlin和Java之间的差异一点都不为过。面对Kotlin这种能减轻我们工作量的工具，我们有什么理由不去学习它呢？我相信有效地使用Kotlin会对你的身心带来巨大的愉悦，在使用Kotlin的过程中，它的简洁和优雅的语法不断地给我带来惊喜，可能这也是Google使用它作为Android官方编程语言的原因吧。Kotlin的语法糖有很多，我至今也还在学习中，接下来我将用三篇文章的篇幅将目前我使用较多的介绍给大家。这篇文章是这个系列的第一章，在这张中我们主要来了解下密封类(sealed class)的用法。 密封类(sealed class)用sealed关键字修饰的类我们称之为密封类，在官方文档中是这么介绍的 密封类用来表示受限的类继承结构，当一个值为有限集中的类型、而不能有任何其他类型。 这是不是很枚举类很相似呢，我认为sealed class比枚举的用法更为灵活，每个枚举类只能存在一个实例，但是密封类的子类可以包含多个不同内部状态的实例。上代码 sealed class Response data class Success(val body: String): Response() data class Error(val code: Int, val message: String): Response() object Timeout: Response() sealed class 自身抽象，它不能直接实例化，但是可以有abstract成员。我们使用IntelliJ IDEA Kotlin Bytecode工具将上面的代码还原程Java代码。 1.Reveal Koltin Bytecode 2.Decompile Kotlin Bytecode to Java code 经过这几步，就可以开始阅读转换后Java代码了 public abstract class Response { private Response() { } // $FF: synthetic method public Response(DefaultConstructorMarker $constructor_marker) { this(); } } 你可能已经在想，seald classes专门为继承而生，因此他们是抽象的。但是，他们怎么会类似enums?下面是Kotlin编译器通过允许您使用Response类的子类作为(as case of)when（）函数的条件时给您带来巨大帮助的时候了。另外，kotlin提供了极大的灵活性(flexibility)，继承sealed class的对象可以是一个data class(数据类)或object fun sugar(response: Response) = when (response) { is Success -> ... is Error -> ... Timeout -> ... } 这样的代码看上去不仅仅是结构清晰，在使用它时，你甚至不用去做额外的强制转换，在条件语句的最后也不再需要else子句了，我们已经覆盖了所有的情况。 fun sugar(response: Response) = when (response) { is Success -> println(response.body) is Error -> println("${response.code} ${response.message}") Timeout -> println(response.javaClass.simpleName) } 不使用sealed关键字的代码是怎样的？可以用IntelliJ IDEA Kotlin Bytecode转换成Java看下 public final void sugar(@NotNull Response response) { Intrinsics.checkParameterIsNotNull(response, "response"); String var3; if (response instanceof Success) { var3 = ((Success)response).getBody(); System.out.println(var3); } else if (response instanceof Error) { var3 = "" + ((Error)response).getCode() + ' ' + ((Error)response).getMessage(); System.out.println(var3); } else { if (!Intrinsics.areEqual(response, Timeout.INSTANCE)) { throw new NoWhenBranchMatchedException(); } var3 = response.getClass().getSimpleName(); System.out.println(var3); } } 可见使用Kotlin我们减少了多少代码量。 使用when()方法自由的排列组合接下来我们看看枚举类和when()的配合。 enum class Employee { DEV_LEAD, SENIOR_ENGINEER, REGULAR_ENGINEER, JUNIOR_ENGINEER } enum class Contract { PROBATION, PERMANENT, CONTRACTOR, } Employee枚举定义了Company中的所有角色，Contract枚举包含了所有类型的员工合同。通过这两个枚举的排列组合我们要返回正确的SafariBookAccess。 fun access(employee: Employee, contract: Contract): SafariBookAccess 然后用定义SafariBooksAccess sealed class SafariBookAccess data class Granted(val expirationDate: DateTime) : SafariBookAccess() data class NotGranted(val error: AssertionError) : SafariBookAccess() data class Blocked(val message: String) : SafariBookAccess() 在access()方法中做排列组合 fun access(employee: Employee, contract: Contract): SafariBookAccess { return when (employee) { SENIOR_ENGINEER -> when (contract) { PROBATION -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT -> Granted(DateTime()) CONTRACTOR -> Granted(DateTime()) } REGULAR_ENGINEER -> when (contract) { PROBATION -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT -> Granted(DateTime()) CONTRACTOR -> Blocked("Access blocked for $contract.") } JUNIOR_ENGINEER -> when (contract) { PROBATION -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT -> Blocked("Access blocked for $contract.") CONTRACTOR -> Blocked("Access blocked for $contract.") } else -> throw AssertionError() } } emm，这样写不够简洁，上述代码存在以下问题： 过多的when()方法。可以用Pair避免嵌套(nesting) 改变枚举类参数的顺序，使用Pair&lt;Contract, Employee&gt;()提高可读性 将返回相同的case合并 改为单表达式函数(Single-Expression functions) 然后，我们来改造一下这段代码 fun access(contract: Contract, employee: Employee) = when (Pair(contract, employee)) { Pair(PROBATION, SENIOR_ENGINEER), Pair(PROBATION, REGULAR_ENGINEER), Pair(PROBATION, JUNIOR_ENGINEER) -> NotGranted(AssertionError("Access not allowed on probation contract.")) Pair(PERMANENT, SENIOR_ENGINEER), Pair(PERMANENT, REGULAR_ENGINEER), Pair(PERMANENT, JUNIOR_ENGINEER), Pair(CONTRACTOR, SENIOR_ENGINEER) -> Granted(DateTime(1)) Pair(CONTRACTOR, REGULAR_ENGINEER), Pair(CONTRACTOR, JUNIOR_ENGINEER) -> Blocked("Access for junior contractors is blocked.") else -> throw AssertionError("Unsupported case of $employee and $contract") } 现在看上去是不是很简洁了，但是还能更加简洁： fun access(contract: Contract, employee: Employee) = when (contract to employee) { PROBATION to SENIOR_ENGINEER, PROBATION to REGULAR_ENGINEER -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT to SENIOR_ENGINEER, PERMANENT to REGULAR_ENGINEER, PERMANENT to JUNIOR_ENGINEER, CONTRACTOR to SENIOR_ENGINEER -> Granted(DateTime(1)) CONTRACTOR to REGULAR_ENGINEER, PROBATION to JUNIOR_ENGINEER, CONTRACTOR to JUNIOR_ENGINEER -> Blocked("Access for junior contractors is blocked.") else -> throw AssertionError("Unsupported case of $employee and $contract") } 希望这些语法糖能对你有所帮助，剩下的我们将在Part2中讲解。 转自 Piotr Ślesarew @ Medium 6 magic sugars that can make your Kotlin codebase happier — Part 1编写 snoopy@we1code.cn]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin作用域函数(Scope Functions)]]></title>
    <url>%2F2019%2F03%2F22%2FKotlin%E5%9F%BA%E7%A1%80-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言Kotlin中有5种作用域函数，分别是： let, run, with, apply, and also 它们并没有任何特性，但是使用他们可以让我们的代码更加简洁，具备更好的可读性。我们可以在这找到它们的源码。下面我将分析这些方法的区别。 分析可以看到其实文档上已经有说明了，它们之间的区别在于： 引用上下文的方式 返回值 每个作用域函数使用两种访问上下文对象的方式之一：作为lambda接收器（this）或作为lambda自变量（it）。两者都提供相同的功能，因此我将描述在每种情况下的利弊，并提供有关其用法的建议。 thisrun, with, apply通过关键字this将上下文作为lambda的接收器。因此，在其lambda中，该对象的用法跟在普通类函数中一样。在大多数情况下，可以省略this直接使用接收器对象的成员变量，从而使代码更加简洁。但是如果省略了this，就很难区分出接收器对象的成员变量和外部变量或方法。因此，如果在lambda中操作对象，像是调用它的方法或是给属性赋值，推荐使用这三种作用域函数。 itlet, also将上下文对象作为lambda表达式的参数。如果在作用域中没有定义参数名，则默认为it。it比this更短，使用it的表达式更加易读。但是在调用对象方法和参数时，不能像this一样隐式调用。因此，当对象被用作方法参数时，推荐使用这两种作用域函数。 返回值 apply, also 返回上下文对象 let, run, with 返回lambda表达式的结果 如何选择使用为了更方便我们选择使用，官方给出了不少示例 letlet 可以被用在在调用链的结果上执行一个或者多个方法。 val numbers = mutableListOf("one", "two", "three", "four", "five") numbers.map { it.length }.filter { it > 3 }.let { println(it) // and more function calls if needed } 如果代码块中只有一个方法，并将it作为参数，可以将lambda简写成(::) val numbers = mutableListOf("one", "two", "three", "four", "five") numbers.map { it.length }.filter { it > 3 }.let(::println) let经常被用在执行non-null values的代码块。要对非空对象进行操作，需要使用安全操作符?. val str: String? = "Hello" //processNonNullString(str) // compilation error: str can be null val length = str?.let { println("let() called on $it") processNonNullString(it) // OK: 'it' is not null inside '?.let { }' it.length } with官方建议使用with不返回结果(“with this object, do the following.”)，如下： val numbers = mutableListOf("one", "two", "three") with(numbers) { println("'with' is called with argument $this") println("It contains $size elements") } run当你的lambda表达式中含有对象的初始化和返回值的计算时run就很有用了。 val service = MultiportService("https://example.kotlinlang.org", 80) val result = service.run { port = 8080 query(prepareRequest() + " to port $port") } // the same code written with let() function: val letResult = service.let { it.port = 8080 it.query(it.prepareRequest() + " to port ${it.port}") } apply主要用作操作接收对象的成员，最典型的例子就是对象的配置。可以理解成”apply the following assignments to the object”。 val adam = Person("Adam").apply { age = 32 city = "London" } 将接收对象作为返回值，你能很容易的将apply置入调用链中做更为复杂的处理。 alsoalso适用于将上下文对象作为参数的操作。also可以用作不改变对象的额外操作，像是打印日志或打印调试信息。通常，你可以从调用链中移除also而不会破坏程序原有的逻辑。可以将also理解成”and also do the following”。 总结可以参考下面的流程图 官方给出的对比表格： Function Object reference Return value Is extension function let it Lambda result Yes run this Lambda result Yes run - Lambda result No: called without the context object with this Lambda result No: takes the context object as an argument apply this Context object Yes also it Context object Yes 一句话总结： 对非空对象执行lambda：let 将表达式作为局部变量引入：let 对象配置：apply 对象配置并计算结果：run 需要表达式的运行语句：no-extension run 额外的操作：also 将对象的调用方法分组：with 总结语尽管作用域方法可以使代码更为简洁，但是请避免过度使用它：这样会减少代码的可读性并且可能导致错误。避免嵌套作用域函数，链式调用它们的时候要格外小心。 参考作用域函数kotlin standard function]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Lambda and Extension]]></title>
    <url>%2F2019%2F03%2F22%2Fkotlin%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Extension Function(扩展函数) Extension Function 能在已经存在的类中添加新的方法或者属性，即使这些类来自库或者SDK中。在函数内部，我们可以访问类的公共函数和属性而不需要任何限定符，就好像这个函数就在这个类的内部一样。（注意：从技术上将，它并没有修改现有类，只是在声明的类中创建了static public final函数） 举个栗子 object KotMain { @JvmStatic fun main(args: Array&lt;String>) { val person = "snoopy" person.say("hello") } fun String.say(sth: String) { println("$this say $sth") } } 反编译后我们可以看到生成的java代码 public final class KotMain { public static final KotMain INSTANCE; public static final void main(@NotNull String[] args) { Instrinsics.checkParameterIsNotNull(args, "args"); String person = "snoopy"; INSTANCE.say(person, "hello"); } public final void say(@NotNull String $this$say, @NotNull String sth) { Instrinsics.checkParameterIsNotNull($this$say, "$this$say"); Instrinsics.checkParameterIsNotNull(sth, "sth"); String var3 = $this$say + ' ' + sth; System.out.println(var3); } } 可以看到只是增加了一个final方法。 接下来看看如何在Android项目中运用它 可以生成任何Android View实例的函数 inline fun&lt;reified V: View> v(context: Context, init: V.() -> Unit): V{ val instance = V::class.java.getConstructor(context::class.java) val view = instace.newInstance(context) view.init() return view } dp-px拓展 fun View.dp2px(dp: Float) { return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, context.resource.displayMetrics) } 添加fragment inline fun FragmentManager.inTransaction(func: FragmentTransaction.() -> Unit) { val fragmentTransaction = begainTransaction() fragmentTransaction.func() fragmentTransaction.commit() } //使用 supportFragmentManager.inTransaction { add(R.id.container, fragment) //other operation } High Order FunctionHigh Order Function 在 kotlin 的官网中有很明确的解释: Higher-Order FunctionsA higher-order function is a function that takes functions as parameters, or returns a function.高阶函数是将函数作为参数或返回函数的函数。 High Order Function 中函数作为参数的情况 inline fun test1(func:Int.() -> Unit) { func(1) } inline fun Int.test2(func:Int.() -> Unit) { func() } public final void test1(int $this$test1, Function1 call) { call.invoke($this$test) } public final void test2(Function1 call) { call.invoke(1) } Lambda with Receiver什么是Lambda with Receiver? Extension Function + Lambda = Lambda with Receiver，它允许你在没有任何限定符的情况下调用lambda中对象的方法。 inline function在kotlin中，函数是一等公民，所以我们可以传递函数或者像其它普通类型一样返回它们。然而，这些函数在运行时可能会产生一些性能上的问题，它们作为对象存储造成了额外的内存开销，这时候就轮到inline登场了，在一些使用High Order Function的场景中，我们一般用inline（内联）去修饰它，这样可以减少调用开销。我们依然从源码出发，通过反编译，看看使用High Order Function编译成Java是什么样子的。 object KotMain { @JvmStatic fun main(args: Array&lt;String>) { noInline { println("调用中") } inlineFunc { println("调用中") } } fun noInline(call: ()->Unit) { println("调用前") call() println("调用后") } inline fun inlineFunc(call: ()->Unit) { println("调用前") call() println("调用后") } } 再来看看java代码 public final class KotMain { public static final KotlinMain INSTANCE; public static final void main(String[] args) { //no inline INSTANCE.noInline(new Function() { @Override public void invoke() { System.out.println("调用中"); } }) //inline System.out.println("调用前"); System.out.println("调用中"); System.out.println("调用后"); } public final void noInline(Function func) { println("调用前"); func.invoke() println("调用后"); } } 大家可以非常直观的看到结论，不使用内联修饰符，每次调用这个函数都会初始化一个Function实例，显然会造成内存开销，而使用内联修饰符，不会创建Function实例，而会将回调函数内部的代码复制到call site中。 参考 kotlin-extension functionKotlin里的Extension Functions实现原理分析How to Add a Fragment the Kotlin way]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码混淆]]></title>
    <url>%2F2018%2F05%2F29%2FAndroid%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[前言最近在用Kotlin撸App，准备发版了，做下代码混淆，想用原来的混淆逻辑，但是发现各种报错，头大的很，觉得是自己关于混淆的知识积累不够多，是应该系统的学习一下了！顺便在此记录下遇到的坑。那下面我们开始吧。 代码混淆开启代码混淆只要在app.gradle文件下配置proguardFiles buildTypes { release { minifyEnabled true //是否开启混淆 zipAlignEnabled true //对齐zip debuggable false // 是否debug versionNameSuffix "_release" // 版本命名后缀 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' // 混淆文件 signingConfig signingConfigs.release } ... } proguard-android.txt 是android自带的混淆规则，我们只需要在proguard-rules.pro这个文件中配置我么的混淆规则就可以了。 Proguard混淆流程 压缩（shrink）：检测并移除代码中无用的类、字段、方法和特性 优化（optimize）：对字节码进行优化，移除无用指令 混淆（obfuscate）：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名 预检（preveirfy）：在java平台上对处理后的代码进行预检，确保加载的class文件时可执行的 混淆规则 Proguard关键字 描述 keep 保留类和类中的成员，防止被混淆或移除 keepnames 保留类和类中的成员，防止被混淆，成员没有被引用会被移除 keepclassmembers 只保留类中的成员，防止被混淆或移除 keepclassmembernames 只保留类中的成员，防止被混淆，成员没有引用会被移除 keepclasseswithmembers 保留类和类中的成员，防止被混淆或移除，保留指明的成员，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。 keepclasseswithmembernames 保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。 通配符 描述 field 匹配类中的所有字段 method 匹配类中的所有方法 init 匹配类中的所有构造函数 * 匹配任意长度字符，但不含包名分隔符（.）。 ** 匹配任意长度字符，并且包含包名分隔符（.）。 *** 匹配任意参数类型 … 匹配任意长度任意类型参数 举例：我们完整的包名是com.xxx.ui.MainAct，使用com.*或者com.xxx.\*都是无法匹配的，正确的写法是com.xxx.\*.\*，或者com.xxx.ui.* 避免混淆的因素 native method：因为native是根据方法名去调用的，若混淆后会导致找不到此方法名。 反射相关的方法和类：反射原理就是通过方法名和类名去实例化相应的对象，调用相关的方法。 setXX和getXX方法：这里指的是通过配置文件直接生成相应的set和get方法的相关库，所以javaBean类很多情况下不能做混淆。 第三方jar包：这个需要具体情况具体分析，很多库都会提供默认的混淆配置，大多数情况可以不用做混淆。 处理混淆失败问题通常混淆失败导致gradle构建项目失败，原因在输出的错误日志上并不明显，我们可以在Build Output中找到构建出错的task，例如我构建失败的任务是transformClassesAndResourcesWithProguardForBaiduRelease，因此我可以执行 gradlew transformClassesAndResourcesWithProguardForBaiduRelease -- stacktrace 这样我们就能在shell中看清楚到底是什么地方出错啦。 参考ProGuard manualAndroid混淆Android 代码混淆零基础入门ProGuard 最全混淆规则说明Android 混淆：proguard实践]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自动打包Android应用]]></title>
    <url>%2F2018%2F04%2F28%2Fjenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言已经用Jenkins做过很多Android自动化打包的配置了，无奈记性不咋地，每配一次就要查一次资料，踩同样的坑，浪费不少时间和精力，更是被一些莫名其妙的问题折磨到抓狂，于是我决定在此把Jenkins的配置流程和遇到的坑整理、记录下来（其实早就想这么做了，但是懒癌晚期），方便以后做一些查阅。 基本步骤全局工具配置在系统管理中做全局工具配置，如下图配置 JAVA_HOME、GRADLE_HOME 指向JDK的安装目录和Gradle的解压目录，然后配置Jenkins的全局变量，这里我配置了python的路径，GRADLE_USER_HOME，这个变量用作gradle的缓存目录，还配置了ANDROID_HOME指向AndroidSdk的目录。 基础工程配置基础工程配置分为配置构建参数、源码管理、配置触发器、配置构建工具、构建后的一些操作 构建任务重命名 配置构建参数选择参数化构建过程&gt;选项参数 源码管理选择git作为版本控制工具 配置触发器解释下触发器的各个选项 触发远程构建 (例如,使用脚本)GitHub hook trigger for GITScm polling其他工程构建后触发定时构建Help for feature: 定时构建 轮询 SCM格式为 *第一个星号表示分钟，取值0~59第二个星号表示小时，取值0~23第三个星号表示一个月内的天数，取值1~31第四个星号表示第几个月，取值1~12第五个星号表示一周的第几天，取值0~7 多渠道打包配置配置参数 接入友盟//build.gradle 配置 productFlavors { yingyongbao { } huawei { } } productFlavors.all { flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } 加固我在项目使用的是乐固加固，首先去下载他们的jar包。进入项目配置文件开始配置： 配置构建后操作，执行打包后再执行加固，如下图： 接下来转到加固项目的配置中，可以将下载下来的jar包做版本管理，也可以直接放在项目根目录中，配置构建步骤： 再签名然鹅加固完之后并没有结束，需要进行再签名， 加固过程不可避免的会破坏签名，因此加固后的包需重签名，未签名应用将无法顺利安装。 这里我是又另外建了一个项目，应该还有比较好的做法比如构建后执行什么的(需要另装插件) 主要看看签名脚本是怎么写的 import sys, os print('使用apksiger命令为apk签名') files = os.listdir('./') jks_file = None apk_file = None for file in files: if file.endswith('.jks'): jks_file = file elif file.endswith('.apk'): apk_file = file else: print(file) if jks_file == None or apk_file == None: print('当前目录不存在签名文件或者apk文件，请确认签名文件在当前目录下') sys.exit(1) file_name=apk_file zipalign_name=file_name.split('.apk')[0]+'_zipalign.apk' command='zipalign -v -p 4 {0} {1}'.format(file_name, zipalign_name) os.system(command) jks_name=jks_file key_alias = 'bonadeTravel' ks_pass = 'bonadetravel888' key_pass = 'bonadetravel888' apk_name=zipalign_name.split('.apk')[0]+'_signed.apk' command='apksigner sign --ks {0} --ks-key-alias {1} --ks-pass pass:{2} --key-pass pass:{3} --out {4} {5}'.format(jks_name, key_alias, ks_pass, key_pass, apk_name, zipalign_name) os.system(command) 执行构建脚本clean assemble${channel}${buildType} --stacktrace //如果需要打所有渠道包 assemble${buildType} --stacktrace 构建后的操作构建完成后的操作: 提取apk文件 上传到蒲公英 jenkins中生成二维码 通知测试人员 tips想修改一下apk文件输出目录，于是修改build.gradle applicationVariants.all { variant -> variant.outputs.each { output -> def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) { if(!outputFile.name.contains("debug")){ def fileName = outputFile.name.replace(".apk", "-${defaultConfig.versionName}.apk") output.outputFile = new File("C:\\Users\\user\\Desktop\\apk\\${defaultConfig.versionName}", fileName) } } } } 在4.0+gradle方法稍有不同 applicationVariants.all { variant -> variant.outputs.all { // 自定义输出路径 但是getPackageApplication()将在19年底被移除 variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath + File.separator + "outputs") outputFileName = "AppName-${variant.flavorName}-${variant.buildType.name}-v${variant.versionName}_${time()}.apk" } 最终版本 applicationVariants.all { variant -> variant.outputs.all { def newName def timeNow if ("true".equals(IS_JENKINS)) { timeNow = JENKINS_TIME variant.packageApplicationProvider.get().outputDirectory = new File(project.rootDir.absolutePath + File.separator + "apks") newName = "xxx-v${APP_VERSION}-${timeNow}-${variant.buildType.name}.apk" } else { timeNow = getDate() if (variant.buildType.name.equals('debug')) { newName = "xxx-v${APP_VERSION}-debug.apk" } else { newName = "xxx-v${APP_VERSION}-${timeNow}-${variant.buildType.name}.apk" } } outputFileName = "${newName}" } } 遇到的坑在jenkins中编译的时候报错找不到abc_ab_share_pack_mtrl_alpha.9.pngwtf没见过这种错误啊，我估摸着会不会是路径太长的原因，于是在gradle.properties中配置了android.buildCacheDir=F\://androidCache，但是，并没有卵用，秉承着不解决问题不罢休的态度，我又浪费了一个下午。终于，在stackoverflow上，看到有个哥们提到在jenkins中设置GRADLE_USER_HOME这个环境变量，随便指向一个目录。然后就不报错了。我的内心是崩溃的，好吧，总算是解决了，但是为什么AndroidStudio下编译就不会报错呢。 com.sun.org.apache.xerces.internal.impl.io.MalformedByteSequenceException: 3 字节的 UTF-8 序列的字节 3 无效又碰到一个奇怪的问题，这个坑是databinding框架产生的，由于我是在linux上开发的，jenkins环境部署在本地的windows上，在xml中databinding的表达式中如果出现了中文字符，就会报编码错误，于是我只能硬着头皮修改布局文件，把中文字符移到资源文件中。 开启混淆后报错，proguard-rules.pro文件配置出错Execution failed for task ':app:transformClassesAndResourcesWithProguardForRelease'. 通过执行 gradlew --stacktrace task xxx 可以看到具体的报错信息，主要是不能混淆的文件没有忽略掉，逐个干掉就行了。 jenkins使用不了系统的环境变量配置一下jenkins的环境变量然后重启生效 jenkins控制台出现中文乱码jenkins环境变量中添加 key: LANG value: zh.CH.UTF-8 参考用apksigner进行批量签名的脚本乐固加固FAQ 结语上面记录的问题只不过是诸多问题的冰山一角，以后我遇到的jenkins相关的问题都会记录于此。想要熟练运用Android打包，看样子还是要深入研究一下gradle才行呐。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
