<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin语法糖 Part3]]></title>
    <url>%2Fme%2F2019%2F04%2F05%2FKotlin%E8%AF%AD%E6%B3%95%E7%B3%96Part3%2F</url>
    <content type="text"><![CDATA[前言在前面的两篇文章中，我们了解到了： sealed when() with() inline function and reified type 在这章中，我会给大家分享我是如何使用Kotlin委托机制的。 Kotlin的委托机制Kotlin有一个内置的委托模式。在一些书中也提及委托模式是实现继承的一个很好的替代方式，在Kotlin使用它进行聚合非常容易： interface Navigable { val onNavigationClick: (()->Unit)? } interface Searchable { val searchText:String } class Component(navigation: Navigable, searchable: Searchable): Navigable by navigable, Searchabe by searchable 使用by关键字，即可委托navigation、searchable的所有行为。比起Java，Kotlin减少了大量的模板代码。如果你把interface标记为internal，你会发现编译不能通过 ‘public’ function exposes its ‘internal’ parameter type xxx Kotlin编译器不允许暴露模块的内部组件，如果想在不暴露Navigable，Searchable的前提下解决这个问题，你只需要做： 移除构造器 使用组合代替聚合 定义包含Navigable和Searchable方法名的ComponentInterface interface ComponentInterface { val onNavigationClick: (()->Unit)? var searchText: String } class Component: ComponentInterface { private val navigable: Navigable = NavigableImpl() private val searchable: Searchable = SearchableImpl() override val onNavigationClick: (()->Unit)? get() = navigable.onNavigationClick override var searchText: String = "" get() = searchable.searchText set(value) { field = value searchable.searchText = value } } 经过改造后，你发现代码从零模板的聚合变成了看上去很讨厌的组合方式。但是先别哭，Kotlin总能给你带来愉悦的编码体验。Kotlin不仅支持使用by关键字对指定对象进行方法委派，还具有委托属性的机制。你可能已经在使用lazy关键字初始化对象时接触到了它的这一机制了。 private val lazyProperty by lazy { "" } 怎么从使用lazy()上来改造上面组合的代码呢，请看代码： class ReferencedProperty&lt;T>(private val get: () -> T, private val set: (T) -> Unit = {}) { operator fun getValue(thisRef: Any?, property: KProperty&lt;*>): T = get() operator fun setValue(thisRef: Any?, property: KProperty&lt;*>, value: T) = set(value) } fun &lt;T> ref(property: KMutableProperty0&lt;T>) = ReferencedProperty(property::get, property::set) fun &lt;T> ref(property: KProperty0&lt;T>) = ReferencedProperty(property::get) ReferencedProperty用两个方法作为参数，并定义了两个函数： get函数返回泛型T set函数以T作为参数 getValue()调用get() setValue()调用set() 最重要的一点是你需要知道操作符用到了属性代理机制。在ReferencedProperty类下，你会发现两个返回ReferencedProperty的泛型方法，第一个用于var，第二个用于val。现在让我们用ref()简化代码 class Component : ComponentInterface { private val navigable: Navigable = NavigableImpl() private val searchable: Searchable = SearchableImpl() override val onNavigationClick by ref(navigable::onNavigationClick) override var searchText by ref(searchable::searchText) } 希望看完这三章你能有些许收获。 参考6 magic sugars that can make your Kotlin codebase happier — Part 3]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin语法糖 Part2]]></title>
    <url>%2Fme%2F2019%2F03%2F30%2Fkotlin%E8%AF%AD%E6%B3%95%E7%B3%96Part2%2F</url>
    <content type="text"><![CDATA[前言在第一章中，我们学会了如何使用sealed classes，以及when()配合Pair或Triple使用做多重条件判断。 在这一章中，我想跟大家分享一下with()和inline reified的基本使用。 使用with()函数with()函数位于Standard.kt，是Kotlin标准函数之一，大家可以看看，掌握好这些函数对于我们简化编程有很大的帮助，有时间我会另开一章分享我平时使用到它们的地方，当然也非常欢迎大家评论分享使用技巧。假设你从未使用过with()函数，我们可以先看看源码： inline fun &lt;T, R> with(receiver: T, block: T.() -> R): R Calls the specified function block with the given receiver as its receiver and returns its result. 大体的意思是调用receiver中的方法然后返回它的结果： val receiver: String = "Fructos" val block: String() -> Unit = { println(toUpperCase()) println(toLowerCase()) println(capitalize()) } val result: Unit = with&lt;String, Unit>(receiver, block) //简化一下代码 with(sugar) { println(toUpperCase()) println(toLowerCase()) println(capitalize()) } 在block中你可以调用到receiver的方法而且不需要任何限定符，在block的最后返回你需要的数据类型就可以了。在项目中我经常使用它在p层传递限定符像是view.show(),view.hide() interface View { fun show() fun hide() fun reset() fun clear() } class Presenter(private val view: View) { fun present(isFructos:Boolean) = with(view) { if(isFructos) { show() hide() } else { hide() clear() } } } inline reified我们先分析一下下面的代码 abstact class Item class MediaItem: Item() { val media = ... } class IconItem: Item() { val icon = ... } interface Renderer { fun render(view: View, item:Item) } class MediaItemRenderer: Renderer { override fun render(view: View, item: Item) { if(item !is MediaItem) { throw AssertionError("Item is not an instance of MediaItem") } view.showMedia(item.media) view.reset() } } class IconItemRenderer: Renderer { override fun render(view: Viewm, item: Item) { if(item !is IconItem) { throw AssertionError("Item is not an instance of IconItem") } view.showIcon(item.icon) view.reset() } } 上述代码有很多冗余的地方，其实很明显你就能看出MediaItemRenderer和IconItemRenderer在render()函数中存在着相同的逻辑，现在，我们用inline reified来改造它，首先将render函数中的逻辑提取出来： fun&lt;T> withCorrectType(toBeChecked: Item, block: (T) -> Unit) { if(toBeChecked !is T) { throw IllegalArgumentException("invalid Type") } block.invoke(toBeChecked) } 然而，这样做并不能通过编译，会报错 Cannot check for instance of erased type: T 产生这种错误是因为泛型机制。 During the type erasure process, the Java compiler erases all type parameters and replaces each with its first bound if the type parameter is bounded,or Object if the type parameter is unbounded.-docs.oracle.com so, 可以防止防止泛型T被清除吗？在Kotlin中一切都有可能，使用inline reified，就能修复这个问题。 class MediaItemRenderer: Renderer { override fun render(view: View, item: Item) = with(view) { withCorrectType&lt;MediaItem>(item) { show {it.media()} reset() } } } class IconItemRenderer: Renderer { override fun render(view: View, item: Item) = with(view) { withCorrectType&lt;IconItem>(item) { clear() show {it.icon()} } } } inline fun&lt;reified T> withCorrectType(toBeChecked: Item, block: (T) -> Unit) { if(toBeChecked !is T) { throw ... } block.invoke(toBeChecked) } 使用reified修饰符Kotlin compiler保留了你的类型，当然这是必须在使用inline的前提下。 以上就是第二章的全部了，在第三章中我们将展示更多的Kotlin小技巧。 参考6 magic sugars that can make your Kotlin codebase happier — Part 2]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin语法糖 Part1]]></title>
    <url>%2Fme%2F2019%2F03%2F23%2Fkotlin%E8%AF%AD%E6%B3%95%E7%B3%96Part1%2F</url>
    <content type="text"><![CDATA[Kotlin给我们提供了大量的工具和语法糖让我们能够更为便利的去编程，让代码有更好的可读性和可扩展性。写更少的代码做更多的事，用这句话概括Kotlin和Java之间的差异一点都不为过。面对Kotlin这种能减轻我们工作量的工具，我们有什么理由不去学习它呢？我相信有效地使用Kotlin会对你的身心带来巨大的愉悦，在使用Kotlin的过程中，它的简洁和优雅的语法不断地给我带来惊喜，可能这也是Google使用它作为Android官方编程语言的原因吧。Kotlin的语法糖有很多，我至今也还在学习中，接下来我将用三篇文章的篇幅将目前我使用较多的介绍给大家。这篇文章是这个系列的第一章，在这张中我们主要来了解下密封类(sealed class)的用法。 密封类(sealed class)用sealed关键字修饰的类我们称之为密封类，在官方文档中是这么介绍的 密封类用来表示受限的类继承结构，当一个值为有限集中的类型、而不能有任何其他类型。 这是不是很枚举类很相似呢，我认为sealed class比枚举的用法更为灵活，每个枚举类只能存在一个实例，但是密封类的子类可以包含多个不同内部状态的实例。上代码 sealed class Response data class Success(val body: String): Response() data class Error(val code: Int, val message: String): Response() object Timeout: Response() sealed class 自身抽象，它不能直接实例化，但是可以有abstract成员。我们使用IntelliJ IDEA Kotlin Bytecode工具将上面的代码还原程Java代码。 1.Reveal Koltin Bytecode 2.Decompile Kotlin Bytecode to Java code 经过这几步，就可以开始阅读转换后Java代码了 public abstract class Response { private Response() { } // $FF: synthetic method public Response(DefaultConstructorMarker $constructor_marker) { this(); } } 你可能已经在想，seald classes专门为继承而生，因此他们是抽象的。但是，他们怎么会类似enums?下面是Kotlin编译器通过允许您使用Response类的子类作为(as case of)when（）函数的条件时给您带来巨大帮助的时候了。另外，kotlin提供了极大的灵活性(flexibility)，继承sealed class的对象可以是一个data class(数据类)或object fun sugar(response: Response) = when (response) { is Success -> ... is Error -> ... Timeout -> ... } 这样的代码看上去不仅仅是结构清晰，在使用它时，你甚至不用去做额外的强制转换，在条件语句的最后也不再需要else子句了，我们已经覆盖了所有的情况。 fun sugar(response: Response) = when (response) { is Success -> println(response.body) is Error -> println("${response.code} ${response.message}") Timeout -> println(response.javaClass.simpleName) } 不使用sealed关键字的代码是怎样的？可以用IntelliJ IDEA Kotlin Bytecode转换成Java看下 public final void sugar(@NotNull Response response) { Intrinsics.checkParameterIsNotNull(response, "response"); String var3; if (response instanceof Success) { var3 = ((Success)response).getBody(); System.out.println(var3); } else if (response instanceof Error) { var3 = "" + ((Error)response).getCode() + ' ' + ((Error)response).getMessage(); System.out.println(var3); } else { if (!Intrinsics.areEqual(response, Timeout.INSTANCE)) { throw new NoWhenBranchMatchedException(); } var3 = response.getClass().getSimpleName(); System.out.println(var3); } } 可见使用Kotlin我们减少了多少代码量。 使用when()方法自由的排列组合接下来我们看看枚举类和when()的配合。 enum class Employee { DEV_LEAD, SENIOR_ENGINEER, REGULAR_ENGINEER, JUNIOR_ENGINEER } enum class Contract { PROBATION, PERMANENT, CONTRACTOR, } Employee枚举定义了Company中的所有角色，Contract枚举包含了所有类型的员工合同。通过这两个枚举的排列组合我们要返回正确的SafariBookAccess。 fun access(employee: Employee, contract: Contract): SafariBookAccess 然后用定义SafariBooksAccess sealed class SafariBookAccess data class Granted(val expirationDate: DateTime) : SafariBookAccess() data class NotGranted(val error: AssertionError) : SafariBookAccess() data class Blocked(val message: String) : SafariBookAccess() 在access()方法中做排列组合 fun access(employee: Employee, contract: Contract): SafariBookAccess { return when (employee) { SENIOR_ENGINEER -> when (contract) { PROBATION -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT -> Granted(DateTime()) CONTRACTOR -> Granted(DateTime()) } REGULAR_ENGINEER -> when (contract) { PROBATION -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT -> Granted(DateTime()) CONTRACTOR -> Blocked("Access blocked for $contract.") } JUNIOR_ENGINEER -> when (contract) { PROBATION -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT -> Blocked("Access blocked for $contract.") CONTRACTOR -> Blocked("Access blocked for $contract.") } else -> throw AssertionError() } } emm，这样写不够简洁，上述代码存在以下问题： 过多的when()方法。可以用Pair避免嵌套(nesting) 改变枚举类参数的顺序，使用Pair&lt;Contract, Employee&gt;()提高可读性 将返回相同的case合并 改为单表达式函数(Single-Expression functions) 然后，我们来改造一下这段代码 fun access(contract: Contract, employee: Employee) = when (Pair(contract, employee)) { Pair(PROBATION, SENIOR_ENGINEER), Pair(PROBATION, REGULAR_ENGINEER), Pair(PROBATION, JUNIOR_ENGINEER) -> NotGranted(AssertionError("Access not allowed on probation contract.")) Pair(PERMANENT, SENIOR_ENGINEER), Pair(PERMANENT, REGULAR_ENGINEER), Pair(PERMANENT, JUNIOR_ENGINEER), Pair(CONTRACTOR, SENIOR_ENGINEER) -> Granted(DateTime(1)) Pair(CONTRACTOR, REGULAR_ENGINEER), Pair(CONTRACTOR, JUNIOR_ENGINEER) -> Blocked("Access for junior contractors is blocked.") else -> throw AssertionError("Unsupported case of $employee and $contract") } 现在看上去是不是很简洁了，但是还能更加简洁： fun access(contract: Contract, employee: Employee) = when (contract to employee) { PROBATION to SENIOR_ENGINEER, PROBATION to REGULAR_ENGINEER -> NotGranted(AssertionError("Access not allowed on probation contract.")) PERMANENT to SENIOR_ENGINEER, PERMANENT to REGULAR_ENGINEER, PERMANENT to JUNIOR_ENGINEER, CONTRACTOR to SENIOR_ENGINEER -> Granted(DateTime(1)) CONTRACTOR to REGULAR_ENGINEER, PROBATION to JUNIOR_ENGINEER, CONTRACTOR to JUNIOR_ENGINEER -> Blocked("Access for junior contractors is blocked.") else -> throw AssertionError("Unsupported case of $employee and $contract") } 希望这些语法糖能对你有所帮助，剩下的我们将在Part2中讲解。 转自 Piotr Ślesarew @ Medium 6 magic sugars that can make your Kotlin codebase happier — Part 1编写 snoopy@we1code.cn]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Lambda and Extension]]></title>
    <url>%2Fme%2F2019%2F03%2F22%2Fkotlin%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Extension Function Extension Function 能在已经存在的类中添加新的方法或者属性，即使这些类来自库或者SDK中。在函数内部，我们可以访问类的公共函数和属性而不需要任何限定符，就好像这个函数就在这个类的内部一样。（注意：从技术上将，它并没有修改现有类，只是在声明的类中创建了static public final函数） 举个栗子 object KotMain { @JvmStatic fun main(args: Array&lt;String>) { val person = "snoopy" person.say("hello") } fun String.say(sth: String) { println("$this say $sth") } } 反编译后我们可以看到生成的java代码 public final class KotMain { public static final KotMain INSTANCE; public static final void main(@NotNull String[] args) { Instrinsics.checkParameterIsNotNull(args, "args"); String person = "snoopy"; INSTANCE.say(person, "hello"); } public final void say(@NotNull String $this$say, @NotNull String sth) { Instrinsics.checkParameterIsNotNull($this$say, "$this$say"); Instrinsics.checkParameterIsNotNull(sth, "sth"); String var3 = $this$say + ' ' + sth; System.out.println(var3); } } 可以看到只是增加了一个final方法。 接下来看看如何在Android项目中运用它 可以生成任何Android View实例的函数 inline fun&lt;reified V: View> v(context: Context, init: V.() -> Unit): V{ val instance = V::class.java.getConstructor(context::class.java) val view = instace.newInstance(context) view.init() return view } dp-px拓展 fun View.dp2px(dp: Float) { return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, context.resource.displayMetrics) } 添加fragment inline fun FragmentManager.inTransaction(func: FragmentTransaction.() -> Unit) { val fragmentTransaction = begainTransaction() fragmentTransaction.func() fragmentTransaction.commit() } //使用 supportFragmentManager.inTransaction { add(R.id.container, fragment) //other operation } High Order FunctionHigh Order Function 在 kotlin 的官网中有很明确的解释: Higher-Order FunctionsA higher-order function is a function that takes functions as parameters, or returns a function.高阶函数是将函数作为参数或返回函数的函数。 High Order Function 中函数作为参数的情况 inline fun test1(func:Int.() -> Unit) { func(1) } inline fun Int.test2(func:Int.() -> Unit) { func() } public final void test1(int $this$test1, Function1 call) { call.invoke($this$test) } public final void test2(Function1 call) { call.invoke(1) } Lambda with Receiver什么是Lambda with Receiver? Extension Function + Lambda = Lambda with Receiver，它允许你在没有任何限定符的情况下调用lambda中对象的方法。 inline function在kotlin中，函数是一等公民，所以我们可以传递函数或者像其它普通类型一样返回它们。然而，这些函数在运行时可能会产生一些性能上的问题，它们作为对象存储造成了额外的内存开销，这时候就轮到inline登场了，在一些使用High Order Function的场景中，我们一般用inline（内联）去修饰它，这样可以减少调用开销。我们依然从源码出发，通过反编译，看看使用High Order Function编译成Java是什么样子的。 object KotMain { @JvmStatic fun main(args: Array&lt;String>) { noInline { println("调用中") } inlineFunc { println("调用中") } } fun noInline(call: ()->Unit) { println("调用前") call() println("调用后") } inline fun inlineFunc(call: ()->Unit) { println("调用前") call() println("调用后") } } 再来看看java代码 public final class KotMain { public static final KotlinMain INSTANCE; public static final void main(String[] args) { //no inline INSTANCE.noInline(new Function() { @Override public void invoke() { System.out.println("调用中"); } }) //inline System.out.println("调用前"); System.out.println("调用中"); System.out.println("调用后"); } public final void noInline(Function func) { println("调用前"); func.invoke() println("调用后"); } } 大家可以非常直观的看到结论，不使用内联修饰符，每次调用这个函数都会初始化一个Function实例，显然会造成内存开销，而使用内联修饰符，不会创建Function实例，而会将回调函数内部的代码复制到call site中。 参考 kotlin-extension functionKotlin里的Extension Functions实现原理分析How to Add a Fragment the Kotlin way]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码混淆]]></title>
    <url>%2Fme%2F2018%2F05%2F29%2FAndroid%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[前言最近在用Kotlin撸App，准备发版了，做下代码混淆，想用原来的混淆逻辑，但是发现各种报错，头大的很，觉得是自己关于混淆的知识积累不够多，是应该系统的学习一下了！顺便在此记录下遇到的坑。那下面我们开始吧。 代码混淆开启代码混淆只要在app.gradle文件下配置proguardFiles buildTypes { release { minifyEnabled true //是否开启混淆 zipAlignEnabled true //对齐zip debuggable false // 是否debug versionNameSuffix "_release" // 版本命名后缀 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' // 混淆文件 signingConfig signingConfigs.release } ... } proguard-android.txt 是android自带的混淆规则，我们只需要在proguard-rules.pro这个文件中配置我么的混淆规则就可以了。 Proguard混淆流程 压缩（shrink）：检测并移除代码中无用的类、字段、方法和特性 优化（optimize）：对字节码进行优化，移除无用指令 混淆（obfuscate）：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名 预检（preveirfy）：在java平台上对处理后的代码进行预检，确保加载的class文件时可执行的 混淆规则 Proguard关键字 描述 keep 保留类和类中的成员，防止被混淆或移除 keepnames 保留类和类中的成员，防止被混淆，成员没有被引用会被移除 keepclassmembers 只保留类中的成员，防止被混淆或移除 keepclassmembernames 只保留类中的成员，防止被混淆，成员没有引用会被移除 keepclasseswithmembers 保留类和类中的成员，防止被混淆或移除，保留指明的成员，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。 keepclasseswithmembernames 保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。 通配符 描述 field 匹配类中的所有字段 method 匹配类中的所有方法 init 匹配类中的所有构造函数 * 匹配任意长度字符，但不含包名分隔符（.）。 ** 匹配任意长度字符，并且包含包名分隔符（.）。 *** 匹配任意参数类型 … 匹配任意长度任意类型参数 举例：我们完整的包名是com.xxx.ui.MainAct，使用com.*或者com.xxx.\*都是无法匹配的，正确的写法是com.xxx.\*.\*，或者com.xxx.ui.* 避免混淆的因素 native method：因为native是根据方法名去调用的，若混淆后会导致找不到此方法名。 反射相关的方法和类：反射原理就是通过方法名和类名去实例化相应的对象，调用相关的方法。 setXX和getXX方法：这里指的是通过配置文件直接生成相应的set和get方法的相关库，所以javaBean类很多情况下不能做混淆。 第三方jar包：这个需要具体情况具体分析，很多库都会提供默认的混淆配置，大多数情况可以不用做混淆。 处理混淆失败问题通常混淆失败导致gradle构建项目失败，原因在输出的错误日志上并不明显，我们可以在Build Output中找到构建出错的task，例如我构建失败的任务是transformClassesAndResourcesWithProguardForBaiduRelease，因此我可以执行 gradlew transformClassesAndResourcesWithProguardForBaiduRelease -- stacktrace 这样我们就能在shell中看清楚到底是什么地方出错啦。 参考ProGuard manualAndroid混淆Android 代码混淆零基础入门ProGuard 最全混淆规则说明Android 混淆：proguard实践]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自动打包Android应用]]></title>
    <url>%2Fme%2F2018%2F04%2F28%2Fjenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言已经用Jenkins做过很多Android自动化打包的配置了，无奈记性不咋地，每配一次就要查一次资料，踩同样的坑，浪费不少时间和精力，更是被一些莫名其妙的问题折磨到抓狂，于是我决定在此把Jenkins的配置流程和遇到的坑整理、记录下来（其实早就想这么做了，但是懒癌晚期），方便以后做一些查阅。 基本步骤全局工具配置在系统管理中做全局工具配置，如下图配置 JAVA_HOME、GRADLE_HOME 指向JDK的安装目录和Gradle的解压目录，然后配置Jenkins的全局变量，这里我配置了python的路径，GRADLE_USER_HOME，这个变量用作gradle的缓存目录，还配置了ANDROID_HOME指向AndroidSdk的目录。 基础工程配置基础工程配置分为配置构建参数、源码管理、配置触发器、配置构建工具、构建后的一些操作 配置构建参数选择参数化构建过程&gt;选项参数 源码管理选择git作为版本控制工具 配置触发器解释下触发器的各个选项 触发远程构建 (例如,使用脚本)GitHub hook trigger for GITScm polling其他工程构建后触发定时构建Help for feature: 定时构建 轮询 SCM格式为 *第一个星号表示分钟，取值0~59第二个星号表示小时，取值0~23第三个星号表示一个月内的天数，取值1~31第四个星号表示第几个月，取值1~12第五个星号表示一周的第几天，取值0~7 多渠道打包配置配置参数 接入友盟//build.gradle 配置 productFlavors { yingyongbao { } huawei { } wandoujia { } baidu { } xiaomi { } oppo { } vivo { } } productFlavors.all { flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } 360加固执行构建脚本clean assemble${channel}${buildType} --stacktrace //如果需要打所有渠道包 assemble${buildType} --stacktrace 构建后的操作构建完成后的操作: 提取apk文件 上传到蒲公英 jenkins中生成二维码 通知测试人员 tips想修改一下apk文件输出目录，于是修改build.gradle applicationVariants.all { variant -> variant.outputs.each { output -> def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) { if(!outputFile.name.contains("debug")){ def fileName = outputFile.name.replace(".apk", "-${defaultConfig.versionName}.apk") output.outputFile = new File("C:\\Users\\user\\Desktop\\apk\\${defaultConfig.versionName}", fileName) } } } } 在4.0+gradle方法稍有不同 applicationVariants.all { variant -> variant.outputs.all { // 自定义输出路径 但是getPackageApplication()将在19年底被移除 variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath + File.separator + "outputs") outputFileName = "AppName-${variant.flavorName}-${variant.buildType.name}-v${variant.versionName}_${time()}.apk" } 最终版本 applicationVariants.all { variant -> variant.outputs.all { def newName def timeNow if ("true".equals(IS_JENKINS)) { timeNow = JENKINS_TIME variant.packageApplicationProvider.get().outputDirectory = new File(project.rootDir.absolutePath + File.separator + "apks") newName = "xqc-travel-v${APP_VERSION}-${timeNow}-${variant.buildType.name}.apk" } else { timeNow = getDate() if (variant.buildType.name.equals('debug')) { newName = "xqc-travel-v${APP_VERSION}-debug.apk" } else { newName = "xqc-travel-v${APP_VERSION}-${timeNow}-${variant.buildType.name}.apk" } } outputFileName = "${newName}" } } 遇到的坑在jenkins中编译的时候报错cannot find abc_ab_share_pack_mtrl_alpha.9.pngwtf没见过这种错误啊，我估摸着会不会是路径太长的原因，于是在gradle.properties中配置了android.buildCacheDir=F\://androidCache，但是，并没有卵用，秉承着不解决问题不罢休的态度，我又浪费了一个下午。终于，在stackoverflow上，看到有个哥们提到在jenkins中设置GRADLE_USER_HOME这个环境变量，随便指向一个目录。然后就不报错了。我的内心是崩溃的，好吧，总算是解决了，但是为什么AndroidStudio下编译就不会报错呢。 [com.sun.org.apache.xerces.internal.impl.io.MalformedByteSequenceException: 3 字节的 UTF-8 序列的字节 3 无效。]又碰到一个奇怪的问题，这个坑是databinding框架产生的，由于我是在linux上开发的，jenkins环境部署在本地的pc上，在xml中databinding的表达式中如果出现了中文字符，就会报编码错误，于是我只能硬着头皮修改布局文件，把中文字符移到资源文件中。 开启混淆后报错，proguard-rules.pro文件配置出错。 Execution failed for task ':app:transformClassesAndResourcesWithProguardForRelease'. 结语上面记录的问题只不过是诸多问题的冰山一角，以后我遇到的jenkins相关的问题都会记录于此。想要熟练运用Android打包，看样子还是要深入研究一下gradle才行呐。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
